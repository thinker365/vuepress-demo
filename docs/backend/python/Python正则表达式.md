Python正则表达式
============================================
#### 核心语法
- 正则表达式是一种特殊的字符串模式，用于匹配一组字符串；
- 正则表达式包含普通字符和元字符（特殊字符）；
- 对于其中的元字符，正则表达式赋予了它们特殊的含义；
- 所以在进行匹配前必须先使特其“转义”，即转化为普通字符；
- 通过反斜杠字符 \ 放在这些字符前面来实现。

**一些常用的、易错的元字符：**
1. [] 表示匹配 [] 中所有字符的任意一个，注意只有 1 个
	- 例如，我们 [0-9] 就是匹配 0、1、……、9 中任意一个数字。
2. 在[]中加上一个-就表示范围
	- 例如，[a-zA-z0-9]包括了所有大小写字母，以及0到9的数字。
3. 在[]内部的第一个位置加上^，表示不取[]中任意一个字符
	- 例如 [^abc] 就表示“不是 a，也不是 b，还不是 c”；
	- 关于[]常见错误用法是：用[ab|bc]来表示“ab或bc”，实际上它等同于[abc|]，得出的结果是“a或b或c或|”这4个字符（单字符）的任意一个；
	- 如果想要得到“ab 或 bc”的结果，这里可以改成 (ab|bc)。
4. 需特别注意，[] 里面的特殊符有五个：[、]、-、\、^，其他都是普通字符，包括 *、.、? 等
5. 点号.匹配换行之外的任意字符
6. 换行符为\n，当我们匹配的字符之间存在不打印的\n时，就算我们的正则表达式看上去与实际字符串完全匹配，但是我们在进行操作时无法匹配
7. \s 匹配任何空白字符，包括空格、TAB、换行符等，\S 匹配任何非空白字符
	- \s 与 \S 互为反义；
	- 此外，我们要注意分辨 [\s\S] 与 . 的区别，[\s\S] 表示“所有”，. 表示“不包括 \n”，前者范围大于后者。
9. 数量字符 *、+、?、{}
	- *表示它前面的字符出现 0 到无数次，例如 ab*c 就可以获取到“ac、abc、abbc、abbbc”等中间包含或者不包含 b 的数据；
	- +表示这个字符出现 1 到无数次，例如 ab+c 就可以匹配到“abc、abbc、abbbc”等中间包含 b 的数据；
	- ？表示这个字符出现 0~1 次，例如 ab?c 就只能匹配到“ac”“abc”这两类数据；
	- 如果是 {3} 这种形式就代表该字符出现 3 次，如果是 {3，5} 就代表该字符出现 3~5 次。

10. | 常用于从多个数据中选多个字符
	- 前面提到的[]有选择其中一个字符功能，但假如不是一个字符，就需要用 | 分开，比如 http|ftp|svn；
	- | 的作用域是一直往后直到遇到括号；
	- 对于源字符串 http abc ftp abc spn abc，如果使用 http|ftp|spn abc 的表达式，最后匹配的结果是“http，ftp，spn abc”；
	- 如果想得到“http abc，ftp abc，spn abc”，就需要这样写正则表达式：(?:http|ftp|spn)abc。

11. () 表示数据分界和取数据
	- () 有一个作用是用于数据分界，这个和我们平常使用的（）差不多；
	- () 还有一个重要的作用就是取数据，被 () 圈起来的元素会自动被分组提取出来，从左往右从 1 开始依次编号分组；
	- 如果我们想要在正则表达式中引用这个分组，可以用 \ 加上分组号，如 \1。当没有括号的时候，默认提取整个符合正则表达式的字符。

12. ?:分界作用
	- 在上面 (?:http|ftp|spn)abc 的例子中，如果我们不加上 ?: ，最后就会提取“http，ftp，spn”出来，而不是“http abc，ftp abc，spn abc”；
	- 到这儿，应该已经知道 ?: 的作用了，就是不提取 () 中的元素，使 () 仅仅起分界作用。

13. ^、$、\b、\B
	- 定位符 ^ 表示一个字符串的开始位置；
	- $ 表示一个字符串结束的位置；
	- \b 表示单词之间的位置，例如单词间的空格；
	- \B 表示非单词间的位置。
	

#### Python正则表达式的写法
**正则表达式的编写要领**
1. 定锚点
	- 需要的数据位于”xxx”的后面，所以将”xxx”作为一个锚点，意思就是我们需要的数据就在这个位置；
	- 锚点后面就是目标数据，所以将目标数据加上一个小括号 ()，表示这里是需要获取的地方，括号内的内容将进行匹配并返回；
	- 如src="(.*?)"。
2. 去噪点
	- 字符串中剩余的数据自然是多余的，同样使用正则表达式来表示这些多余的信息，但是不使用小括号 ()，这样就不会将这部分信息提取出来；
	- 于是，得到正则表达式 <img.*?src="(.*?)">。
3. 取数据
	- 得到了总的正则表达式，就可以将其代入到字符串中获取数据了。

**正则表达式在 Python 中的应用场景**
- 想要在Python中使用正则表达式，首先要使用import re语句导入re模块
1. 生成
	```
	举例：
	strs=r'<imgalt="loading"class="lazyloadloaded"src="https://th.wallhaven.cc/small/e7/e76pew.jpg">'
	reStr = r'<img.*?src="(.*?)">’
	pattern = re.compile(reStr)
	result = re.findall(pattern，strs）
	```
	- re.compile这个函数将会返回一个具有正则表达式匹配规则的匹配模式pattern；
	- 这个pattern才真正具有从字符串strs中得到相应数据的功能；
	- compile 函数的作用是让计算机知道这个字符串是一个符合规则的正则表达式，而不是一个普通的字符串；
	- 如果不使用re.compile函数将reStr普通字符串转换为pattern正则匹配模式，将这一行代码注释掉，直接使用reStr这一字符串进行匹配，也能够进行匹配；
	- 这是因为findall函数在执行时，自动将reStr字符串转换成了正则表达式；
	- 使用 compile 函数的目的是提高效率；
	- 因为经过 compile 函数的编译后，pattern 就是一个正则表达式了，在今后使用时就不再需要编译了；findall可以直接进行匹配过程；
	- 如果不经过compile 函数 ，findall 在执行时，就要每次都先将reStr字符串转换成正则表达式，再进行匹配过程。

2. 定位
	- 定位就是获取目标数据的位置信息；
	- 这里有两个函数供我们使用，一个是 match 函数，另一个是 search 函数；
	- search(pattern,string)
	- match(pattern,string)
	- 其中，Pattern 是正则表达式；string 是需要匹配的字符串；
	- 这两个函数都是从字符串中匹配一个数据，即使字符串中有多个符合匹配的数据，函数还是只返回第一个匹配到的数据及其位置信息；
	```
	headers = {

		"UserAgent":"Mozilla/5.0(WindowsNT10.0;Win64;x64)AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.81 Safari/537.36"

	}
	url = "https://wallhaven.cc/toplist?page=1"
	resp = requests.get(url=url, headers=headers)
	strs = resp.text
	result = re.search(pattern,strs)
	<re.Match object;span=(22601,22644),match='https://th.wallhaven.cc/small/pk/pkgkkp.jpg'>
	```
	- search 函数只获取了众多图片数据的第一个匹配到的数据;
	- 若是使用函数 match 进行匹配，得到的结果却为空;
	- 因为match 函数默认是从字符串开头进行匹配，若是开头处就与正则表达式不匹配的话，返回结果就直接为空;
	- 而search函数是从头到尾进行匹配，当成功匹配到数据就返回结果，若是从头到尾都没有匹配的数据，才返回空。

3. 显示
	 - findall函数可以将所有匹配到的数据全部返回
	 ```
	 result = re.findall(pattern,strs)
	```
	- 还有一个finditer函数，其功能与findall函数是一样的，也是全局匹配，获取所有匹配的结果；
	- 只是它们返回的数据类型不同，findall返回的是一个列表数据类型，而finditer是返回一个迭代器类型。

4. 替换
	```
	sub(pattern,repl,string,count=0)
	```
	其中，repl 表示替换的字符串，count 表示开始位置。

5. 分割
	```
	split(pattern.string)
	```
	将我们原本需要做几次才能完成的任务，简化为一次就完成。

#### 贪婪匹配与非贪婪匹配

- 元字符.表示任意字符（换行符除外），元字符* 表示前一个字符重复出现 0 次或者是多次，所以我们使用.*就可以匹配任意长度的任意字符了，就是贪婪匹配；
- .*?连在一起，就是非贪婪匹配。